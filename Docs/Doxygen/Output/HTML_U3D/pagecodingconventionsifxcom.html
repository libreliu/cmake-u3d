<HTML>
<HEAD>
<TITLE>Universal 3D:Universal 3D: IFXCOM Coding Conventions</TITLE>
<meta name = "description" content = "">
<meta name = "keywords" content = "">
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<link href="U3D.css" rel="stylesheet" type="text/css">
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="#top">

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0"  BORDER="0">
<TR>
 <TD COLSPAN="2" BACKGROUND="ImagesCommon/top.gif"><IMG SRC="ImagesCommon/top_left.gif" WIDTH="31" HEIGHT="15"></TD>
 <TD COLSPAN="2" BACKGROUND="ImagesCommon/top.gif"></TD>
 <TD COLSPAN="1" WIDTH="100" ><IMG SRC="ImagesCommon/top_right.gif" HEIGHT="15" ></TD>
</TR>
<TR>
  <TD BGCOLOR="#0033ff" WIDTH="31"><TABLE WIDTH="31" CELLPADDING="0" CELLSPACING="0"  BORDER="0"></TABLE></TD>
  <TD WIDTH = "18" VALIGN="top"  ><IMG SRC="ImagesCommon/nav_spacer.gif" BORDER="0" ></TD>
  <TD WIDTH="*" BACKGROUND="ImagesCommon/yellowback2.gif" VALIGN="top" >
  <TABLE WIDTH="290" CELLPADDING="0" CELLSPACING="0"  BORDER="0"></TABLE>
<A class="qindex" href="index.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> main</FONT></B></A>
<A class="qindex" href="hierarchy.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> hierarchy</FONT></B></A>
<A class="qindex" href="annotated.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> annotated types</FONT></B></A>
<A class="qindex" href="classes.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> type index</FONT></B></A>
<A class="qindex" href="functions.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> functions</FONT></B></A>
<A class="qindex" href="globals.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> globals</FONT></B></A>
<A class="qindex" href="files.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> files</FONT></B></A>
<A class="qindex" href="dirs.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> directories</FONT></B></A>
<A class="qindex" href="pages.html"><IMG ALIGN="middle" SRC="ImagesCommon/bullet.gif" BORDER="0"><B><FONT SIZE=-1 FACE="arial" COLOR="#315AFF"> related pages</FONT></B></A>
</TD>
  <TD  WIDTH="*" VALIGN="top" ALIGN="left" BACKGROUND="ImagesCommon/logospacer.gif"><IMG SRC="ImagesCommon/logo_spacer.gif" WIDTH="22" HEIGHT="52"></TD>
  <TD  WIDTH="100" VALIGN="top" ALIGN="right" ><A HREF="http://sourceforge.net/projects/u3d/"><IMG SRC="ImagesCommon/logo.gif"  HEIGHT="52" BORDER="0"></A></TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0"  BORDER="0">
<TR>
<TD WIDTH="39" BACKGROUND="ImagesCommon/left2.gif"  align="left"></TD>
<TD WIDTH="10" BGCOLOR="#eeeeee"></TD>
<TD WIDTH="*" BGCOLOR="#eeeeee">
<BR>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="PageCodingConventionsIFXCOM">IFXCOM Coding Conventions</a></h1>This project uses a C++ based component model that is similar to Microsoft* COM.<p>
Both are interface-oriented programming paradigms, however IFXCOM's overhead is light, it is portable and it only supports C++. This page describes the coding conventions for how to create IFXCOM interfaces and components, as well as how to use them. It is considered an addendum to U3D's general <a class="el" href="pagecodingconventions.html">Coding Conventions</a>.<p>
<hr>
 <h2><a class="anchor" name="SectionGoals">
Goals</a></h2>
The goals originally established for IFXCOM are:<ol type=1>
<li><em>Low-space</em> <em>and</em> <em>runtime</em> <em>costs</em>. No inter-process or inter-thread marshalling or other function invocation overhead. No frequent access to an object registry for object construction. Aggregation is not supported so containment should be used instead.</li><li><em>Easy</em> <em>to</em> <em>use</em>. Familiar to programmers who are familiar with Microsoft* COM. Simple usage model. Clearly documented rules for reference counting and pointer copying.</li><li><em>Portable</em>. Straightforward to port to multiple operating systems and platforms. No need to implement complex subsystems simply to port the code.</li></ol>
<p>
<hr>
 <h2><a class="anchor" name="SectionDefinitions">
Definitions</a></h2>
This page will use the following definitions:<ul>
<li>An <em>interface</em> is an abstract collection of function prototypes that advertise a set of functionality but does not provide any implementation of that functionality and does not declare any storage space. A C++ class without data members that has all of its functions publicly declared as "pure virtual" is an interface.</li><li>A <em>class</em> is a collection of storage members and function prototypes that provides implementation for at least some of its advertised functions (which are usually part of an interface).</li><li>An <em>instantiable</em> <em>class</em> is a class for which an instance can be created. There must be an implementation for each of the functions in the class.</li><li>A <em>component</em> is an instantiable class via a common creation mechanism that supports one or more interfaces.</li><li>An <em>object</em> is a component.</li></ul>
<p>
<hr>
 <h2><a class="anchor" name="SectionComponentAndInterfaceDesign">
Design of Components and Interfaces</a></h2>
<ol type=1>
<li>All subsystems and all objects visible outside their subsystems must be components and use the IFXCOM paradigm. Objects only used internally within a subsystem may use the IFXCOM paradigm, but are not required to.</li><li>When creating new components, begin with the latest IFXCOM templates located in the <code>Source\Templates</code> folder. The templates demonstrate the proper way to implement the common boilerplate code for creating components of both the non-singleton and singleton variety. Templates are also available for interfaces and for creating new IFXCOM plug-in dynamic libraries.</li><li>All components will use IFXCID's for unique identification. They are simply an <a class="el" href="struct_i_f_x_g_u_i_d.html">IFXGUID</a> typedef that's equivalent to a GUID. They are commonly defined in a header file specific to the IFXCOM plug-in dynamic library that they are associated with (for example <a class="el" href="_i_f_x_core_c_i_ds_8h.html">IFXCoreCIDs.h</a>). By convention they are prefixed with <code>CID_</code>. Use Microsoft*'s <code>GUIDGEN.EXE</code> tool to generate them. Do not use the standard Microsoft* COM and OLE header files. Type and macro definitions are provided in the header <a class="el" href="_i_f_x_g_u_i_d_8h.html">IFXGUID.h</a> that are portable.</li><li>All interfaces will use IFXIID's for unique identification. They are simply an <a class="el" href="struct_i_f_x_g_u_i_d.html">IFXGUID</a> typedef that is equivalent to a GUID. They are commonly defined in the interface header file that they are associated with. By convention they are prefixed with <code>IID_</code>. Use Microsoft*'s <code>GUIDGEN.EXE</code> tool to generate them. Do not use the standard Microsoft* COM and OLE header files. Type and macro definitions are provided in the header <a class="el" href="_i_f_x_g_u_i_d_8h.html">IFXGUID.h</a> that are portable.</li><li>All components must support the <a class="el" href="class_i_f_x_unknown.html">IFXUnknown</a> interface (minimally). The <a class="el" href="class_i_f_x_unknown.html">IFXUnknown</a> interface consists of three functions for lifetime management and obtaining interfaces supported by the component. It is functionally equivalent to IUnknown. Note that IFXREFIID is just a reference to an IFXIID. <div class="fragment"><pre class="fragment"><span class="keyword">class </span><a class="code" href="class_i_f_x_unknown.html">IFXUnknown</a>
{
    <span class="keyword">public</span>:
        <span class="keyword">virtual</span> <a class="code" href="_i_f_x_data_types_8h.html#a31">U32</a>         AddRef() = 0;
        <span class="keyword">virtual</span> <a class="code" href="_i_f_x_data_types_8h.html#a31">U32</a>         Release() = 0;
        <span class="keyword">virtual</span> <a class="code" href="_i_f_x_result_8h.html#a43">IFXRESULT</a>   QueryInterface( 
                                <a class="code" href="struct_i_f_x_g_u_i_d.html">IFXREFIID</a>   <a class="code" href="struct_i_f_x_g_u_i_d.html">interfaceId</a>, 
                                <span class="keywordtype">void</span>**      <a class="code" href="_i_f_x_core_static_8cpp.html#a1">ppInterface</a> ) = 0;
};
</pre></div></li><li>Components may optionally support custom interfaces. All custom interfaces must derive solely from another interface (multiple inheritance should be avoided, virtual inheritance is also slower and generally is not needed unless implementation inheritance is used in the component implementation). The top-most interface must always be <a class="el" href="class_i_f_x_unknown.html">IFXUnknown</a>.</li><li>Names of custom interfaces must end with the suffix <code>X</code> if any of their functions are known to throw exceptions. This is necessary even if a function calls another function that throws exceptions. However, it is not necessary if such called functionality is wrapped in a try-catch block and the function itself does not directly throw any exceptions.</li><li>C++ references to interfaces and other types are allowed as parameters in interface function prototypes. Reference-style parameters should be used solely for either input or output. If used for input, the parameter must be marked as constant in the prototype. Note: Using references properly can reduce the need for basic pointer parameter validation checking in function implementations.</li><li>All components will have an IFXCOM compatible factory function defined that is used by <code>IFXCreateComponent</code> indirectly for instantiation. The component class declaration must define the factory function as a friend. It will hand back a pointer to the requested interface on the created object if it supports it. Each component's factory function must be registered with the Core DL for this to work properly. The factory function might look like the following example: <div class="fragment"><pre class="fragment"><span class="keyword">friend</span> <a class="code" href="_i_f_x_result_8h.html#a43">IFXRESULT</a>    CIFXMyComponent_Factory(
                        <a class="code" href="struct_i_f_x_g_u_i_d.html">IFXREFIID</a>   <a class="code" href="struct_i_f_x_g_u_i_d.html">interfaceId</a>,
                        <span class="keywordtype">void</span>**      <a class="code" href="_i_f_x_core_static_8cpp.html#a1">ppInterface</a> );
</pre></div></li><li>All components will have private (or protected) constructors, accessible only through the friend factory function. The destructor function should be declared private.</li><li>All component class constructors should be empty. If a custom interface with an <code>Initialize</code> function is not necessary, a call to a <code>RobustConstructor</code> function should be made by the component's factory function so that an error can be returned and handed back to the client. The templates demonstrate this technique.</li><li>Immediately before a reference to a component is returned by the component's factory function, it should increase the newly instantiated component's reference count by calling its <code>AddRef</code> function.</li><li>The implementation of the <a class="el" href="class_i_f_x_unknown.html">IFXUnknown</a> interface's <code>QueryInterface</code> function must be reflexive (a QI for an interface from the requested interface should succeed), symmetric (it should be possible to QI back to the original interface used to QI for a different one) and transitive (any interface supported by a component can be QIed from any of its interfaces). Additionally, <code>QueryInterface</code> must always say yes or no for an interface for any particular instance of a component. <code>QueryInterface</code> must always return the same pointer value when the <a class="el" href="class_i_f_x_unknown.html">IFXUnknown</a> interface is requested. However, it can return a different pointer value each time other interfaces are requested. This is useful for dynamically allocating subcomponents.</li><li>To define a new component for the IFXCOM plug-in dynamic library it is associated with:<ul>
<li>The new component description should be added to the <code>gs_componentDescriptorList</code> of this plug-in dynamic library (refer to the <code>IFXPluginName.cpp</code> template).</li><li>To use this component outside this plug-in dynamic library the appropriate IFXDEFINE_GUID for its IFXCID must be declared (refer to the <code>IFXPluginNameCIDs.h</code> template).</li><li>The header files for all externally exposed interfaces of this component should be included (refer to the <code>IFXPluginNameInterfaces.h</code> template).</li></ul>
</li></ol>
<p>
<hr>
 <h2><a class="anchor" name="SectionPluginDynamicLibraryDesign">
Design of Plug-in Dynamic Libraries</a></h2>
<ol type=1>
<li>The body of the plug-in dynamic library must be implemented. The <code>IFXPluginNameDllMain.cpp</code> file contains the template for Windows* and Linux* specific implementations.</li><li>All required functions that must be exported from the plug-in dynamic library (<code>IFXPluginRegister</code> and <code>IFXPluginCanUnloadNow</code>) must be implemented (refer to the <code>IFXPluginName.cpp</code> template).</li><li>Cross-platform <code>IFXPluginNameStartup</code> and <code>IFXPluginNameShutdown</code> functions must be implemented for plug-in dynamic library initialization and uninitialization (refer to the <code>IFXPluginName.cpp</code> template).</li><li>The IFXDEFINE_GUIDs for all IFXCIDs of components which are considered to be used outside of the dynamic plug-in library must be declared (refer to the <code>IFXPluginNameCIDs.h</code> template).</li><li>All header files for externally exposed interfaces of components defined in the dynamic plug-in library must be included (refer to the <code>IFXPluginNameInterfaces.h</code> template).</li><li>Templates for extension plug-in modifier can be found in <code>Source\Templates\ExtensionModifier</code> folder.</li><li>The plug-in dynamic libraries must statically link with <code>IFXCorePluginStatic.lib</code>.</li><li>All compiled plug-in dynamic libraries must be placed in a <code>Plugins</code> folder that must exist in the same directory as the IFXCore DL. Note: In the future release for Linux, this requirement might be different.</li></ol>
<p>
<hr>
 <h2><a class="anchor" name="SectionComponentAndInterfaceUsage">
Usage of Components and Interfaces</a></h2>
<ol type=1>
<li>The statically linked <code>IFXCoreStatic.lib</code> library provides an easy way to use all available components. It dynamically loads the <code>IFXCore</code> plug-in dynamic library which contains the IFXCOM component system. This component system must be initialized by calling the IFXCOMInitialize function before any creation or usage of IFXCOM components. When no IFXCOM component exist and the component system is no longer needed, call the IFXCOMUninitialize function to unitialize it. During uninitialization the IFXCOM component system checks the ability of plug-in dynamic libraries to be unloaded. If this is not possible for any of plug-in dynamic library, which means that some of the component instances have not been released or some dynamically allocated objects have not been deleted, the IFXCOMUninitialize function returns the warning IFX_W_CANNOT_UNLOAD.</li><li>Components may be created by calling the IFXCreateComponent function. Just specify the desired component's IFXCID, the desired interface's IFXIID (that is supported by the component) and a pointer to a void pointer that will receive a pointer to the desired interface upon successful return. Note: Upon successful return, the caller is responsible for calling the requested interface's <code>Release</code> function. Note: If a type of component is a singleton and there are outstanding interface references to it, any subsequent calls to IFXCreateComponent will hand back interface references to the same object that was already instantiated. <div class="fragment"><pre class="fragment"><a class="code" href="_i_f_x_result_8h.html#a43">IFXRESULT</a>   <a class="code" href="_i_f_x_smart_ptr_8h.html#a0">IFXCreateComponent</a>( 
                <a class="code" href="struct_i_f_x_g_u_i_d.html">IFXREFCID</a>   componentId, 
                <a class="code" href="struct_i_f_x_g_u_i_d.html">IFXREFIID</a>   <a class="code" href="struct_i_f_x_g_u_i_d.html">interfaceId</a>, 
                <span class="keywordtype">void</span>**      <a class="code" href="_i_f_x_core_static_8cpp.html#a1">ppInterface</a> );
</pre></div></li><li>When passing an interface pointer to a function, the caller must not release the interface pointer until the called function returns. This needs to be specifically adhered to when multithreading or reentrancy is involved.</li><li>When a copy of an interface pointer is made that will exist in a wider scope than the original pointer, the interface's <code>AddRef</code> function must be called. When the copy is no longer necessary, the interface's <code>Release</code> function must be called. For example, if a function <code>"Register( IFXCoreServices* pCoreServices )"</code> of a component <code>CIFXTest</code> takes as an argument a pointer to the interface <a class="el" href="class_i_f_x_core_services.html">IFXCoreServices</a> and in the <code>Register</code> function implementation, it copies that pointer into the <code>CIFXTest</code> data member <code>m_pCoreServices</code>, the <code>AddRef</code> function for the <a class="el" href="class_i_f_x_core_services.html">IFXCoreServices</a> interface must be called. Immediately before destroying the instance of <code>CIFXTest</code>, <code>m_pCoreServices</code> should have its <code>Release</code> function called.</li><li>When a client is finished using a component or interface that it has ownership of, the client must call the interface's <code>Release</code> function. A client must never invoke the delete operator on a component. Note: IFXCOM components, when implemented properly and based on the templates, have a private delete operator to prevent this from ever being possible. Note: A client will have ownership of an interface if it ever called a function to receive an interface pointer to a component or it called the <code>AddRef</code> method on the interface (and hopefully kept a pointer to it). For example, calling IFXCreateComponent, calling an interface's <code>QueryInterface</code> function or calling <code>AddRef</code> on an interface pointer received as a parameter and keeping it in a data member.</li></ol>
<p>
<dl compact><dt><b>Note:</b></dt><dd>When it is known ahead-of-time that a reference count cycle between one or more components will occur (or it is discovered that one exists), it can be prevented (or fixed) by using a special common prevention component. This component's id is CID_IFXConnector. Its main interfaces are <a class="el" href="class_i_f_x_connection.html">IFXConnection</a> and <a class="el" href="class_i_f_x_connection_server.html">IFXConnectionServer</a>. It is designed to manage a weak interface reference to a component in a controlled manner so that no clients need to knowingly keep weak references to interfaces and break the IFXCOM rules. Using this special component will make for a more stable engine and won't require custom coding of prevention components such as those already developed to deal with this issue (such as <a class="el" href="class_c_i_f_x_core_services_ref.html">CIFXCoreServicesRef</a> used by <a class="el" href="class_c_i_f_x_core_services.html">CIFXCoreServices</a>).</dd></dl>
<hr>
 <h2><a class="anchor" name="SectionRelatedInformation">
Related Information</a></h2>
<ul>
<li>U3D's general <a class="el" href="pagecodingconventions.html">Coding Conventions</a> </li></ul>
<P>

<TABLE CELLPADDING="0" CELLSPACING="0" BORDER="0">
 <TR><TD>
 <FONT SIZE="-2" FACE="arial"><I>&#169; 1999 - 2006 Intel Corporation. All rights reserved.<BR><BR>
 * Other names and brands may be claimed as the property of others.</I></FONT>
 </TD></TR>
</TABLE>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0">
<TR>
<TD WIDTH="18"><IMG SRC="ImagesCommon/footer1.gif" HEIGHT="45" BORDER="0"></TD>
<TD WIDTH="5" ><IMG SRC="ImagesCommon/footer2.gif" WIDTH="5" HEIGHT="45" BORDER="0"></TD>
<TD WIDTH="28"><IMG SRC="ImagesCommon/footer3.gif" HEIGHT="45" BORDER="0"></TD>
<TD BACKGROUND="ImagesCommon/footer4.gif" WIDTH="*"><IMG SRC="ImagesCommon/footer4.gif" HEIGHT="45" BORDER="0"></TD>
<TD WIDTH="26"><IMG SRC="ImagesCommon/footer5.gif" HEIGHT="45" BORDER="0"></TD>
</TR>
<TR><TD COLSPAN="5"></TD></TR>
</TABLE>


